####################################
Tutorial 5: 提示词技巧
####################################

.. include:: ../links.ref
.. include:: ../tags.ref
.. include:: ../abbrs.ref

============ ==========================
**Abstract** 高效的 AI 提示词技巧
**Authors**  Walter Fan
**Status**   WIP
**Updated**  |date|
============ ==========================

.. contents::
   :local:

为什么提示词很重要
==================

在氛围编程中，提示词（Prompt）是你与 AI 沟通的桥梁。好的提示词可以：

- 获得更准确的代码
- 减少来回修改的次数
- 提高开发效率
- 得到更好的代码质量

.. note::

   **AI 给出什么样的答案，很大程度上取决于你问什么样的问题。**

提示词基础框架
==============

RACE 框架
---------

一个有效的提示词通常包含四个要素：

.. code-block:: text

   RACE 框架

   ┌─────────────────────────────────────────────────────────────────┐
   │                                                                 │
   │   R - Role (角色)                                               │
   │   定义 AI 扮演的角色                                            │
   │   例：你是一个资深 Python 开发者                                 │
   │                                                                 │
   │   A - Action (行动)                                             │
   │   明确要 AI 做什么                                              │
   │   例：帮我实现一个缓存装饰器                                     │
   │                                                                 │
   │   C - Context (上下文)                                          │
   │   提供背景信息                                                  │
   │   例：用于 Flask API，需要支持 Redis                            │
   │                                                                 │
   │   E - Expectation (期望)                                        │
   │   描述期望的输出                                                │
   │   例：包含类型注解和单元测试                                     │
   │                                                                 │
   └─────────────────────────────────────────────────────────────────┘

示例对比
--------

**糟糕的提示词**::

    帮我写一个缓存函数

**好的提示词**::

    【角色】你是一个资深 Python 后端开发者
    【背景】我在开发一个 Flask API，需要缓存频繁查询的数据
    【行动】请帮我实现一个缓存装饰器，要求：
    1. 支持 Redis 作为缓存后端
    2. 支持设置过期时间
    3. 支持自定义缓存 key
    4. 处理 Redis 连接失败的情况
    【期望】
    - 完整的代码实现
    - 类型注解
    - 使用示例
    - 简单的单元测试

提示词技巧
==========

1. 明确具体
-----------

越具体的要求，越好的结果：

**不好**::

    写一个排序函数

**好**::

    写一个 Python 函数，实现：
    - 对字典列表按指定 key 排序
    - 支持升序和降序
    - 支持多个排序字段
    - 处理 key 不存在的情况

2. 提供约束
-----------

告诉 AI 不要做什么：

::

    实现用户注册功能：
    - 使用 FastAPI
    - 不要使用 ORM，直接写 SQL
    - 不要使用第三方验证库
    - 密码使用 bcrypt 加密

3. 给出示例
-----------

用示例说明期望的格式：

::

    将以下数据转换为 CSV 格式：

    输入：
    [
        {"name": "Alice", "age": 30},
        {"name": "Bob", "age": 25}
    ]

    期望输出：
    name,age
    Alice,30
    Bob,25

4. 分步骤请求
-------------

复杂任务分解为多个步骤：

::

    第一步：设计数据库表结构
    - 用户表
    - 订单表
    - 商品表

    请先给出 ER 图和建表语句，确认后再继续。

5. 要求解释
-----------

让 AI 解释它的思路：

::

    实现一个 LRU 缓存，并解释：
    1. 为什么选择这种数据结构
    2. 时间复杂度分析
    3. 可能的优化方向

编程场景提示词模板
==================

代码生成
--------

::

    【任务】实现 {功能描述}
    【技术栈】{语言/框架/版本}
    【要求】
    1. {具体要求 1}
    2. {具体要求 2}
    3. {具体要求 3}
    【约束】
    - {不要做什么}
    - {性能要求}
    【输出】
    - 完整代码
    - 使用示例
    - 简要说明

**实例**::

    【任务】实现一个 HTTP 重试装饰器
    【技术栈】Python 3.11 + httpx
    【要求】
    1. 支持配置最大重试次数
    2. 支持指数退避
    3. 只对特定状态码重试（5xx）
    4. 支持自定义重试条件
    【约束】
    - 不使用第三方重试库
    - 异步函数
    【输出】
    - 完整代码
    - 使用示例
    - 测试用例

代码重构
--------

::

    【当前代码】
    {粘贴代码}

    【问题】
    - {问题 1}
    - {问题 2}

    【重构目标】
    - {目标 1}
    - {目标 2}

    【约束】
    - 保持 API 不变
    - 不引入新依赖

**实例**::

    【当前代码】
    def process_data(data):
        result = []
        for item in data:
            if item['status'] == 'active':
                if item['type'] == 'A':
                    result.append(item['value'] * 2)
                elif item['type'] == 'B':
                    result.append(item['value'] * 3)
        return result

    【问题】
    - 嵌套太深
    - 缺少类型注解
    - 魔法数字

    【重构目标】
    - 降低圈复杂度
    - 添加类型注解
    - 提取常量

Bug 修复
--------

::

    【代码】
    {粘贴代码}

    【问题描述】
    {描述 bug 现象}

    【期望行为】
    {描述正确行为}

    【已尝试】
    {已经尝试过的解决方案}

**实例**::

    【代码】
    async def fetch_users(ids: list[int]) -> list[User]:
        tasks = [get_user(id) for id in ids]
        return await asyncio.gather(*tasks)

    【问题描述】
    当某个 id 不存在时，整个请求失败

    【期望行为】
    单个失败不影响其他，返回成功的结果

    【已尝试】
    - 添加 try-except，但不知道怎么处理 gather

代码解释
--------

::

    【代码】
    {粘贴代码}

    请解释：
    1. 整体功能
    2. 关键步骤
    3. 为什么这样设计
    4. 潜在问题

测试生成
--------

::

    【代码】
    {粘贴代码}

    【测试框架】pytest

    【要求】
    1. 正常情况测试
    2. 边界条件测试
    3. 异常情况测试
    4. 使用 fixture 和参数化

高级技巧
========

1. 角色扮演
-----------

让 AI 扮演特定角色，获得专业视角：

::

    你是一个有 10 年经验的安全专家。
    请审查以下代码的安全问题：
    {代码}

常用角色：

- 资深开发者
- 安全专家
- 性能优化专家
- 代码审查员
- 架构师

2. 思维链（Chain of Thought）
-----------------------------

要求 AI 展示推理过程：

::

    请一步步分析这个算法问题：
    1. 首先理解问题
    2. 分析可能的解法
    3. 选择最优解法并说明原因
    4. 实现代码
    5. 分析时间和空间复杂度

3. 少样本学习（Few-shot）
-------------------------

通过示例教 AI 你想要的格式：

::

    将函数转换为类方法，示例：

    输入：
    def add(a, b):
        return a + b

    输出：
    class Calculator:
        @staticmethod
        def add(a: int, b: int) -> int:
            return a + b

    现在转换这个函数：
    def multiply(a, b):
        return a * b

4. 对比分析
-----------

让 AI 比较不同方案：

::

    比较以下两种缓存实现方案：
    1. 使用 Redis
    2. 使用本地内存（如 cachetools）

    从以下维度分析：
    - 性能
    - 可扩展性
    - 运维成本
    - 适用场景

    给出你的推荐和理由。

5. 迭代优化
-----------

分多轮对话逐步优化：

**第一轮**::

    实现一个基本的 LRU 缓存

**第二轮**::

    添加线程安全支持

**第三轮**::

    添加过期时间功能

**第四轮**::

    优化性能，减少锁竞争

常见错误
========

1. 太模糊
---------

**错误**::

    帮我优化这段代码

**正确**::

    帮我优化这段代码的性能：
    - 当前处理 10000 条数据需要 5 秒
    - 目标：降到 1 秒以内
    - 可以使用多线程

2. 信息过载
-----------

**错误**::

    （粘贴 500 行代码）
    帮我改进这段代码

**正确**::

    这是一个数据处理模块的核心函数（完整代码见附件）：
    （粘贴关键的 50 行）

    主要问题是第 23-35 行的循环效率低，
    请帮我优化这部分。

3. 缺少上下文
-------------

**错误**::

    这段代码报错了，怎么修

**正确**::

    这段代码报错了：

    代码：
    {代码}

    错误信息：
    {完整错误信息}

    环境：Python 3.11, FastAPI 0.100

4. 期望不明确
-------------

**错误**::

    帮我写个 API

**正确**::

    帮我写一个用户管理 API：
    - GET /users - 获取用户列表（支持分页）
    - POST /users - 创建用户
    - GET /users/{id} - 获取单个用户
    - PUT /users/{id} - 更新用户
    - DELETE /users/{id} - 删除用户

    使用 FastAPI，返回统一的响应格式。

实战练习
========

练习 1：代码生成
----------------

使用 RACE 框架，让 AI 生成一个：

- 文件监控工具
- 监控指定目录的文件变化
- 支持过滤特定扩展名
- 变化时执行回调函数

练习 2：代码重构
----------------

找一段你写过的"不太好"的代码，构造提示词让 AI 重构。

练习 3：Bug 修复
----------------

描述一个你遇到过的 bug，看 AI 能否帮你定位和修复。

练习 4：对比分析
----------------

让 AI 比较两种你熟悉的技术方案，评估 AI 的分析质量。

小结
====

本教程介绍了高效的提示词技巧：

- **RACE 框架**: Role, Action, Context, Expectation
- **基本技巧**: 明确具体、提供约束、给出示例
- **高级技巧**: 角色扮演、思维链、少样本学习
- **常见错误**: 太模糊、信息过载、缺少上下文

关键要点：

1. 好的提示词 = 好的结果
2. 越具体越好
3. 迭代优化比一次完美更实际

下一步
------

在下一个教程中，我们将学习 MCP Server，扩展 AI 的能力边界。

练习
====

1. 用 RACE 框架重写你之前的 5 个提示词
2. 收集 10 个好用的提示词模板
3. 对比不同提示词的效果差异
4. 建立你自己的提示词库

参考资源
========

- `Prompt Engineering Guide <https://www.promptingguide.ai/>`_
- `OpenAI Prompt Engineering <https://platform.openai.com/docs/guides/prompt-engineering>`_
- `Anthropic Prompt Engineering <https://docs.anthropic.com/claude/docs/prompt-engineering>`_
